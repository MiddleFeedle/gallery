{"ast":null,"code":"const DB_NAME = 'Storage';\nconst OBJECT_STORE_NAME = 'Pictures';\n\nfunction openDatabasePromise(keyPath) {\n  return new Promise((resolve, reject) => {\n    const dbOpenRequest = window.indexedDB.open(DB_NAME, 1);\n\n    dbOpenRequest.onblocked = () => {\n      reject(\"Что-то пошло не так.\");\n    };\n\n    dbOpenRequest.onerror = err => {\n      console.log('Unable to open indexedDB ' + DB_NAME);\n      console.log(err);\n      reject('Невозможно открыть базу данных.');\n    };\n\n    dbOpenRequest.onupgradeneeded = event => {\n      const db = event.target.result;\n      var objectStore = db.createObjectStore('Pictures', {\n        keyPath: 'id',\n        autoIncrement: true\n      });\n      objectStore.createIndex(\"name\", \"name\", {\n        unique: false\n      });\n      objectStore.createIndex(\"format\", \"format\", {\n        unique: false\n      });\n      objectStore.createIndex(\"height\", \"height\", {\n        unique: false\n      });\n      objectStore.createIndex(\"size\", \"size\", {\n        unique: false\n      });\n      objectStore.createIndex(\"type\", \"type\", {\n        unique: false\n      });\n      objectStore.createIndex(\"date\", \"date\", {\n        unique: false\n      });\n      objectStore.createIndex(\"desc\", \"desc\", {\n        unique: false\n      });\n      objectStore.createIndex(\"tags\", \"tags\", {\n        unique: false,\n        multiEntry: true\n      });\n      objectStore.createIndex(\"value\", \"value\", {\n        unique: false\n      });\n    };\n\n    dbOpenRequest.onsuccess = () => {\n      console.info('Successfully open indexedDB connection to ' + DB_NAME);\n      resolve(dbOpenRequest.result);\n    };\n\n    dbOpenRequest.onerror = reject;\n  });\n} // Оборачиваем функции от ObjectStore, поддерживающие интерфейс IDBRequest\n// в вызов с использованием Promise\n\n\nfunction wrap(methodName) {\n  return function () {\n    const [objectStore, ...etc] = arguments;\n    return new Promise((resolve, reject) => {\n      const request = objectStore[methodName](...etc);\n\n      request.onsuccess = () => resolve(request.result);\n\n      request.onerror = reject;\n    });\n  };\n}\n\nfunction wrapByID(methodName) {\n  return function () {\n    const [objectStore, index, ...etc] = arguments;\n    return new Promise((resolve, reject) => {\n      console.log(index);\n      console.log([methodName]);\n      console.log(...etc);\n      var myIndex = objectStore.index(index);\n      console.log(myIndex);\n      const request = myIndex[methodName](...etc);\n      console.log(request);\n\n      request.onsuccess = () => resolve(request.result);\n\n      request.onerror = reject;\n    });\n  };\n}\n\nconst getByIDPromise = wrapByID('getAll');\nconst deletePromise = wrap('delete');\nconst getAllPromise = wrap('getAll');\nconst getPromise = wrap('get');\nconst putPromise = wrap('put');\nexport default class IndexedDbRepository {\n  constructor(keyPath) {\n    this.error = null;\n    this.keyPath = keyPath; // конструктор нельзя объявить как async\n    // поэтому вынесено в отдельную функцию\n\n    this.openDatabasePromise = this._openDatabase(keyPath);\n  }\n\n  async _openDatabase(keyPath) {\n    try {\n      this.dbConnection = await openDatabasePromise(keyPath);\n    } catch (error) {\n      this.error = error;\n      throw error;\n    }\n  }\n\n  async _tx(txMode, callback) {\n    await this.openDatabasePromise; // await db connection\n\n    const transaction = this.dbConnection.transaction([OBJECT_STORE_NAME], txMode);\n    const objectStore = transaction.objectStore(OBJECT_STORE_NAME);\n    return await callback(objectStore);\n  }\n\n  async save(item) {\n    return this._tx('readwrite', objectStore => putPromise(objectStore, item));\n  }\n\n  async findById(key) {\n    return this._tx('readonly', objectStore => getPromise(objectStore, key));\n  }\n\n  async findByIndex(index, key) {\n    return this._tx('readonly', objectStore => getByIDPromise(objectStore, index, key));\n  }\n\n  async deleteById(key) {\n    return this._tx('readwrite', objectStore => deletePromise(objectStore, key));\n  }\n\n  async findAll() {\n    return this._tx('readonly', objectStore => getAllPromise(objectStore));\n  }\n\n}","map":{"version":3,"sources":["C:/Users/middl/Desktop/DevIT project/devit-project/src/db/connection.js"],"names":["DB_NAME","OBJECT_STORE_NAME","openDatabasePromise","keyPath","Promise","resolve","reject","dbOpenRequest","window","indexedDB","open","onblocked","onerror","err","console","log","onupgradeneeded","event","db","target","result","objectStore","createObjectStore","autoIncrement","createIndex","unique","multiEntry","onsuccess","info","wrap","methodName","etc","arguments","request","wrapByID","index","myIndex","getByIDPromise","deletePromise","getAllPromise","getPromise","putPromise","IndexedDbRepository","constructor","error","_openDatabase","dbConnection","_tx","txMode","callback","transaction","save","item","findById","key","findByIndex","deleteById","findAll"],"mappings":"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","sourcesContent":["\r\nconst DB_NAME = 'Storage';\r\nconst OBJECT_STORE_NAME = 'Pictures';\r\n\r\n\r\nfunction openDatabasePromise( keyPath : string ) : Promise< IDBDatabase > {\r\n  return new Promise(( resolve, reject ) => {\r\n    const dbOpenRequest = window.indexedDB.open( DB_NAME, 1 );\r\n\r\n    dbOpenRequest.onblocked = () => {\r\n      reject(\"Что-то пошло не так.\");\r\n    };\r\n\r\n    dbOpenRequest.onerror = err => {\r\n      console.log( 'Unable to open indexedDB ' + DB_NAME );\r\n      console.log( err );\r\n      reject( 'Невозможно открыть базу данных.');\r\n    };\r\n\r\n    dbOpenRequest.onupgradeneeded = event => {\r\n      const db = event.target.result;\r\n\r\n      var objectStore = db.createObjectStore('Pictures', {keyPath:'id', autoIncrement: true});\r\n\r\n            objectStore.createIndex(\"name\", \"name\", { unique: false });\r\n\r\n            objectStore.createIndex(\"format\", \"format\", { unique: false });\r\n            objectStore.createIndex(\"height\", \"height\", { unique: false });\r\n            objectStore.createIndex(\"size\", \"size\", { unique: false });\r\n            objectStore.createIndex(\"type\", \"type\", { unique: false });\r\n            objectStore.createIndex(\"date\", \"date\", { unique: false });\r\n            objectStore.createIndex(\"desc\", \"desc\", { unique: false });\r\n            objectStore.createIndex(\"tags\", \"tags\", { unique: false, multiEntry:true});\r\n            objectStore.createIndex(\"value\", \"value\", { unique: false });\r\n\r\n    };\r\n\r\n\r\n    dbOpenRequest.onsuccess = () => {\r\n\r\n\r\n\r\n      console.info( 'Successfully open indexedDB connection to ' + DB_NAME );\r\n      resolve( dbOpenRequest.result );\r\n    };\r\n\r\n    dbOpenRequest.onerror = reject;\r\n  } );\r\n}\r\n\r\n// Оборачиваем функции от ObjectStore, поддерживающие интерфейс IDBRequest\r\n// в вызов с использованием Promise\r\n\r\nfunction wrap( methodName ) {\r\n  return function() {\r\n    const [ objectStore, ...etc ] = arguments;\r\n    return new Promise( ( resolve, reject ) => {\r\n      const request = objectStore[ methodName ]( ...etc );\r\n      request.onsuccess = () => resolve( request.result );\r\n      request.onerror = reject;\r\n    } );\r\n  };\r\n}\r\n\r\nfunction wrapByID( methodName ) {\r\n  return function() {\r\n    const [ objectStore, index, ...etc ] = arguments;\r\n    return new Promise( ( resolve, reject ) => {\r\n\r\n      console.log(index);\r\n      console.log([ methodName ]);\r\n      console.log(...etc);\r\n\r\n      var myIndex = objectStore.index(index);\r\n\r\n      console.log(myIndex);\r\n\r\n      const request =  myIndex[ methodName ]( ...etc );\r\n\r\n\r\n\r\n\r\n      console.log(request);\r\n      request.onsuccess = () => resolve( request.result );\r\n      request.onerror = reject;\r\n    } );\r\n  };\r\n}\r\n\r\nconst getByIDPromise = wrapByID( 'getAll' );\r\n\r\nconst deletePromise = wrap( 'delete' );\r\nconst getAllPromise = wrap( 'getAll' );\r\nconst getPromise = wrap( 'get' );\r\nconst putPromise = wrap( 'put' );\r\n\r\nexport default class IndexedDbRepository {\r\n\r\n  dbConnection : ?IDBDatabase;\r\n  error : ?any;\r\n  openDatabasePromise : Promise< IDBDatabase >;\r\n\r\n  constructor( keyPath : string ) {\r\n    this.error = null;\r\n    this.keyPath = keyPath;\r\n    // конструктор нельзя объявить как async\r\n    // поэтому вынесено в отдельную функцию\r\n    this.openDatabasePromise = this._openDatabase( keyPath );\r\n  }\r\n\r\n  async _openDatabase( keyPath : string ) {\r\n    try {\r\n      this.dbConnection = await openDatabasePromise( keyPath );\r\n    } catch ( error ) {\r\n      this.error = error;\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async _tx( txMode : string, callback ) {\r\n  await this.openDatabasePromise; // await db connection\r\n  const transaction  = this.dbConnection.transaction( [ OBJECT_STORE_NAME ], txMode );\r\n  const objectStore  = transaction.objectStore( OBJECT_STORE_NAME );\r\n  return await callback( objectStore );\r\n}\r\n\r\n\r\nasync save( item : any ) : Promise< any > {\r\n  return this._tx( 'readwrite', objectStore => putPromise( objectStore, item ) );\r\n}\r\n\r\nasync findById( key ) : Promise< any > {\r\n    return this._tx( 'readonly', objectStore => getPromise( objectStore, key ) );\r\n  }\r\n\r\n  async findByIndex( index, key ) : Promise< any >\r\n    {\r\n      return this._tx( 'readonly', objectStore => getByIDPromise( objectStore, index, key ) );\r\n    }\r\n\r\n\r\n  async deleteById( key ) : Promise< any > {\r\n    return this._tx( 'readwrite', objectStore => deletePromise( objectStore, key ) );\r\n  }\r\n\r\nasync findAll() : Promise< any[] > {\r\n   return this._tx( 'readonly', objectStore => getAllPromise( objectStore ) );\r\n }\r\n\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}